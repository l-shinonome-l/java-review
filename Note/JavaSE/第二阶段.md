# 面向对象编程高级
## 类变量和类方法
### 类变量
用单独变量统计类的实例个数会很麻烦，所以要用类变量/静态变量/静态属性

使用static关键字修饰变量，该变量就变成该类所有实例所共享的，也就是静态变量，在类加载时生成，随类消亡而毁灭

定义：`访问修饰符 static 数据类型 变量名;`（推荐）/ `static 访问修饰符 数据类型 变量名;`

使用`类名/实例名.静态变量名`就可以访问

jkd8以前在方法区，8及以后在堆中类对应的Class实例的尾部

### 类方法
静态方法

定义：`访问修饰符 static 数据返回类型 方法名(){}`（推荐）/ `static 访问修饰符 数据返回类型 方法名(){}`

使用`类名/实例名.静态方法名`就可以访问

免去使用方法必须创建实例的限制，如Math类、Arrays类、Collections集合类，都可以直接使用其中的静态方法来简化代码，自己开发工具类也可以使用静态方法

- 随类加载而加载，在方法区
- 无this参数
- 不允许使用this或super关键字，
- 只能访问静态成员（静态变量+静态方法）
  
## 深入理解main
`public static void main(String[] args) {}`

1. java虚拟机来调用main方法，所以要设定为public
2. 执行main方法时不创建对象，所以必须是static
3. 调用时形参列表为String的数组，数组名是args，执行命令为'java 运行的类名 args[0] args[1] ...'/idea里用Edit Configurations，设置Program arguments即可

main中可以直接调用所在类的静态方法和静态属性，但不能直接访问非静态成员，必须创建一个实例之后才能通过这个实例去访问

## 代码块
也叫初始化块，属于类的成员，类似方法，将逻辑语句用`{}`包裹起来

没有方法名，没有返回，没有参数，只有方法体，不能通过对象或类显式调用，在加载类（有static）或创建对象（没有static）时隐式调用

`修饰符 {};`，修饰符可选，只可以选static，有static的叫静态代码块，没有的叫普通代码块，`;`可写，也可忽略

相当于另一种形式的构造器，多个构造器中有重复语句可以抽取到代码块中，提高代码复用性，代码块的调用优先于构造器

- 有static修饰的代码块对类进行初始化，类加载时执行，只执行一次，没有static修饰的代码块每创建一个对象就执行一次，只调用静态成员不会执行没有static修饰的代码块
- 类加载的情况：
  - 创建对象实例（new）
  - 创建子类对象实例，父类也会被加载
  - 使用类的静态属性或静态方法时，子类调用父类的静态成员只加载父类，调用子类的静态对象父类会被加载
  - 使用反射机制访问类且initialize为true时
  - JVM启动时会加载一些系统类；含有main方法的类在被执行的时候会被加载
  - JDK8 之后，接口中存在default方法，这个接口的实现类初始化时，接口会其之前进行初始化
- 创建对象调用的顺序：调用静态代码块和静态属性初始化（按定义顺序）->调用普通代码块和普通属性的初始化（按定义顺序）->调用构造方法
- 构造器最前面隐含了`super()`和调用普通代码块，所以先执行父类的普通代码块，父类的构造器，再执行本类的普通代码块和构造器中剩下的语句，静态代码块和静态属性在类加载时就执行完毕，先于普通代码块和构造器
- 创建一个子类实例的调用顺序：父类静态代码块和静态属性（按定义顺序）->子类静态代码块和静态属性（按定义顺序）->父类普通代码块和普通属性初始化（按定义顺序）->父类构造方法->子类普通代码块和普通属性初始化（按定义顺序）->子类构造方法
- 静态代码块只能调用静态属性和静态方法，普通代码块随意
## 单例设计模式
设计模式的一种，是静态方法和属性的经典使用。

单例就是只有单个实例，保证整个软件系统中对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法

饿汉式不存在线程安全的问题，懒汉式存在线程安全问题（多个线程在instance为null时同时执行getInstance方法）

饿汉式存在资源浪费，懒汉式不存在

java.lang.Runtime就是经典的单例模式（饿汉式）

- 饿汉式：类加载时，实例就创建了，而不是使用实例时再创建（可能在调用别的静态属性或方法时实例会被创建）。
  1. 构造器私有化（用private修饰构造器）
  2. 在类的内部定义私有静态实例属性并创建对象赋值给这个属性（因为构造器私有化了）
  3. 向外暴露一个静态的公共方法getInstance（因为是static修饰，可以绕过创建实例,直接用类名来调用公共方法）
  ```
  class 类名{
      //私有化构造器
      private 类名(){}
  
      //类内部创建对象
      private static 类名 instance = new 类名();

      //对外暴露实例的静态公共方法
      public static 类名 getInstance(){
          return instance;
      }
  }
  ```
- 懒汉式：只有使用时（调用getInstance方法时）才创建实例
  1. 构造器私有化（用private修饰构造器）
  2. 在类的内部创建私有静态实例属性（这里没有创建对象，是默认值null）
  3. 向外暴露一个静态的公共方法getInstance，如果静态实例属性为null（还没有创建对象），则创建对象，最后返回这个静态实例属性（因为是static修饰，可以绕过创建实例,直接用类名来调用公共方法，只有调用getInstance才会创建实例减少了内存开销）
  ```
  class 类名{
      //私有化构造器
      private 类名(){}
  
      //类内部创建对象
      private static 类名 instance;

      //对外暴露实例的静态公共方法
      public static 类名 getInstance(){
          if (instance == null) {
              instance = new 类名();
          }
          return instance;
      }
  }
  ```
  
## final关键字
可以修饰类、属性、方法和局部变量

使用final的情况：
1. 不希望类被继承 final class 类名{}
2. 不希望父类的某个方法被子类覆盖/重写\(override\) 访问修饰符 final 返回类型 方法名
3. 不希望类的某个属性的值被修改
4. 不希望某个局部变量被修改

使用细节：
1. final修饰的属性一般用XX_XX_XX的形式命名（英文全部大写，单词之间用下划线连接）
2. final修饰的属性在定义时必须初始化，且以后不能修改。1）定义时赋值；2）构造器赋值；3）代码块中赋值
3. 如果final修饰的属性还是静态的话，只能在定义时和静态代码块中初始化赋值
4. final类不能继承，但可以实例化对象
5. 一个类不是final类但是含有final方法的话，该方法虽然不能被重写，但是可以被继承
6. 一个final类中不需要用final修饰方法，因为不能继承类就代表着不存在子类可以重写类中的方法
7. 构造方法不能用final修饰
8. final和static搭配使用的效率更高
9. 包装类（Integer，Double，Float，Boolean）和String都是final类
## 抽象类
当父类的某些方法需要声明，但又不明确如何实现时可以将其声明为抽象方法，这个类也就是抽象类

当类中存在抽象方法（abstracr关键字）时，需要将类也声明为抽象类，抽象方法一般会被子类继承，由子类实现。

使用细节：
1. 抽象类：访问修饰符 abstract 类名{}
2. 抽象方法：访问修饰符 abstract 返回类型 方法名\(参数列表\);//没有方法体，
3. 抽象类不能被实例化
4. 抽象类可以没有抽象方法，也可以有实现了的方法，但含有抽象方法的类一定是抽象类
5. abstract只能修饰类和方法，不能修饰其他东西。
6. 抽象类可以有任意的成员（抽象类还是类）
7. 抽象方法不能有主体（即跟在后面的大括号）
8. 一个不是抽象类的类继承了抽象类就必须实现里面所有的抽象方法。
9. 抽象方法不能使用private（子类无法访问）、final（不能重写）和static（在类加载时就要加载到方法区，但这时子类的静态方法还没创建，不能实现抽象方法）来修饰，因为这些关键字都是和子类重写实现抽象方法相违背的。
10. 抽象类的价值在于设计，框架和设计模式很多都使用了抽象类

### 模版设计模式
模版类里还不确定的部分用抽象方法，确定的部分用普通的方法（普通方法可以调用抽象方法，抽象方法也不能被static修饰，抽象类中的静态方法不能调用非static方法，所以能调用抽象方法的只有非static的普通方法，只能通过实例才能调用，而抽象类又不能实例化，所以抽象类中调用了抽象方法的普通方法只能通过子类的实例化来调用，这时会动态绑定子类中的实现的对应的抽象方法，所以在普通方法中调用抽象方法不会造成执行到抽象方法时该方法还没实现的情况），可以确定抽象方法的类可以继承这个模版类，实现具体功能，这样可以减少代码量
## 接口
## 内部类
