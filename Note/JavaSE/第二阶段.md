# 面向对象编程高级
## 类变量和类方法
### 类变量
用单独变量统计类的实例个数会很麻烦，所以要用类变量/静态变量/静态属性

使用static关键字修饰变量，该变量就变成该类所有实例所共享的，也就是静态变量，在类加载时生成，随类消亡而毁灭

定义：`访问修饰符 static 数据类型 变量名;`（推荐）/ `static 访问修饰符 数据类型 变量名;`

使用`类名/实例名.静态变量名`就可以访问

jkd8以前在方法区，8及以后在堆中类对应的Class实例的尾部

### 类方法
静态方法

定义：`访问修饰符 static 数据返回类型 方法名(){}`（推荐）/ `static 访问修饰符 数据返回类型 方法名(){}`

使用`类名/实例名.静态方法名`就可以访问

免去使用方法必须创建实例的限制，如Math类、Arrays类、Collections集合类，都可以直接使用其中的静态方法来简化代码，自己开发工具类也可以使用静态方法

- 随类加载而加载，在方法区
- 无this参数
- 不允许使用this或super关键字，
- 只能访问静态成员（静态变量+静态方法）
  
## 深入理解main
`public static void main(String[] args) {}`

1. java虚拟机来调用main方法，所以要设定为public
2. 执行main方法时不创建对象，所以必须是static
3. 调用时形参列表为String的数组，数组名是args，执行命令为'java 运行的类名 args[0] args[1] ...'/idea里用Edit Configurations，设置Program arguments即可

main中可以直接调用所在类的静态方法和静态属性，但不能直接访问非静态成员，必须创建一个实例之后才能通过这个实例去访问

## 代码块
也叫初始化块，属于类的成员，类似方法，将逻辑语句用`{}`包裹起来

没有方法名，没有返回，没有参数，只有方法体，不能通过对象或类显式调用，在加载类（有static）或创建对象（没有static）时隐式调用

`修饰符 {};`，修饰符可选，只可以选static，有static的叫静态代码块，没有的叫普通代码块，`;`可写，也可忽略

相当于另一种形式的构造器，多个构造器中有重复语句可以抽取到代码块中，提高代码复用性，代码块的调用优先于构造器

- 有static修饰的代码块对类进行初始化，类加载时执行，只执行一次，没有static修饰的代码块每创建一个对象就执行一次，只调用静态成员不会执行没有static修饰的代码块
- 类加载的情况：
  - 创建对象实例（new）
  - 创建子类对象实例，父类也会被加载
  - 使用类的静态属性或静态方法时，子类调用父类的静态成员只加载父类，调用子类的静态对象父类会被加载
  - 使用反射机制访问类且initialize为true时
  - JVM启动时会加载一些系统类；含有main方法的类在被执行的时候会被加载
  - JDK8 之后，接口中存在default方法，这个接口的实现类初始化时，接口会其之前进行初始化
- 创建对象调用的顺序：调用静态代码块和静态属性初始化（按定义顺序）->调用普通代码块和普通属性的初始化（按定义顺序）->调用构造方法
- 构造器最前面隐含了`super()`和调用普通代码块，所以先执行父类的普通代码块，父类的构造器，再执行本类的普通代码块和构造器中剩下的语句，静态代码块和静态属性在类加载时就执行完毕，先于普通代码块和构造器
- 创建一个子类实例的调用顺序：父类静态代码块和静态属性（按定义顺序）->子类静态代码块和静态属性（按定义顺序）->父类普通代码块和普通属性初始化（按定义顺序）->父类构造方法->子类普通代码块和普通属性初始化（按定义顺序）->子类构造方法
- 静态代码块只能调用静态属性和静态方法，普通代码块随意
## 单例设计模式
设计模式的一种，是静态方法和属性的经典使用。

单例就是只有单个实例，保证整个软件系统中对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法

饿汉式不存在线程安全的问题，懒汉式存在线程安全问题（多个线程在instance为null时同时执行getInstance方法）

饿汉式存在资源浪费，懒汉式不存在

java.lang.Runtime就是经典的单例模式（饿汉式）

- 饿汉式：类加载时，实例就创建了，而不是使用实例时再创建（可能在调用别的静态属性或方法时实例会被创建）。
  1. 构造器私有化（用private修饰构造器）
  2. 在类的内部定义私有静态实例属性并创建对象赋值给这个属性（因为构造器私有化了）
  3. 向外暴露一个静态的公共方法getInstance（因为是static修饰，可以绕过创建实例,直接用类名来调用公共方法）
  ```
  class 类名{
      //私有化构造器
      private 类名(){}
  
      //类内部创建对象
      private static 类名 instance = new 类名();

      //对外暴露实例的静态公共方法
      public static 类名 getInstance(){
          return instance;
      }
  }
  ```
- 懒汉式：只有使用时（调用getInstance方法时）才创建实例
  1. 构造器私有化（用private修饰构造器）
  2. 在类的内部创建私有静态实例属性（这里没有创建对象，是默认值null）
  3. 向外暴露一个静态的公共方法getInstance，如果静态实例属性为null（还没有创建对象），则创建对象，最后返回这个静态实例属性（因为是static修饰，可以绕过创建实例,直接用类名来调用公共方法，只有调用getInstance才会创建实例减少了内存开销）
  ```
  class 类名{
      //私有化构造器
      private 类名(){}
  
      //类内部创建对象
      private static 类名 instance;

      //对外暴露实例的静态公共方法
      public static 类名 getInstance(){
          if (instance == null) {
              instance = new 类名();
          }
          return instance;
      }
  }
  ```
  
## final关键字
可以修饰类、属性、方法和局部变量

使用final的情况：
1. 不希望类被继承 final class 类名{}
2. 不希望父类的某个方法被子类覆盖/重写\(override\) 访问修饰符 final 返回类型 方法名
3. 不希望类的某个属性的值被修改
4. 不希望某个局部变量被修改

使用细节：
1. final修饰的属性一般用XX_XX_XX的形式命名（英文全部大写，单词之间用下划线连接）
2. final修饰的属性在定义时必须初始化，且以后不能修改。1）定义时赋值；2）构造器赋值；3）代码块中赋值
3. 如果final修饰的属性还是静态的话，只能在定义时和静态代码块中初始化赋值
4. final类不能继承，但可以实例化对象
5. 一个类不是final类但是含有final方法的话，该方法虽然不能被重写，但是可以被继承
6. 一个final类中不需要用final修饰方法，因为不能继承类就代表着不存在子类可以重写类中的方法
7. 构造方法不能用final修饰
8. final和static搭配使用的效率更高
9. 包装类（Integer，Double，Float，Boolean）和String都是final类
## 抽象类
当父类的某些方法需要声明，但又不明确如何实现时可以将其声明为抽象方法，这个类也就是抽象类

当类中存在抽象方法（abstracr关键字）时，需要将类也声明为抽象类，抽象方法一般会被子类继承，由子类实现。

使用细节：
1. 抽象类：访问修饰符 abstract 类名{}
2. 抽象方法：访问修饰符 abstract 返回类型 方法名\(参数列表\);//没有方法体，
3. 抽象类不能被实例化
4. 抽象类可以没有抽象方法，也可以有实现了的方法，但含有抽象方法的类一定是抽象类
5. abstract只能修饰类和方法，不能修饰其他东西。
6. 抽象类可以有任意的成员（抽象类还是类）
7. 抽象方法不能有主体（即跟在后面的大括号）
8. 一个不是抽象类的类继承了抽象类就必须实现里面所有的抽象方法。
9. 抽象方法不能使用private（子类无法访问）、final（不能重写）和static（在类加载时就要加载到方法区，但这时子类的静态方法还没创建，不能实现抽象方法）来修饰，因为这些关键字都是和子类重写实现抽象方法相违背的。
10. 抽象类的价值在于设计，框架和设计模式很多都使用了抽象类

### 模版设计模式
模版类里还不确定的部分用抽象方法，确定的部分用普通的方法（普通方法可以调用抽象方法，抽象方法也不能被static修饰，抽象类中的静态方法不能调用非static方法，所以能调用抽象方法的只有非static的普通方法，只能通过实例才能调用，而抽象类又不能实例化，所以抽象类中调用了抽象方法的普通方法只能通过子类的实例化来调用，这时会动态绑定子类中的实现的对应的抽象方法，所以在普通方法中调用抽象方法不会造成执行到抽象方法时该方法还没实现的情况），可以确定抽象方法的类可以继承这个模版类，实现具体功能，这样可以减少代码量

## 接口
给出一些没有实现的方法，将其封装到一起，在某个类要使用的时候，根据具体情况把这些方法写出来

### 基础使用
```
interface 接口名 {
    //属性
    //方法
}

class 类名 implements 接口 {
    自己的属性;
    自己的方法;
    必须实现的接口的抽象方法;
}
```

jdk7.0前接口里的所有方法都没有方法体，8.0后的接口类可以有静态方法（static）、默认方法（default），也就是说接口中可以有方法的具体实现。

接口最大的好处就是统一了相似功能方法的命名规范

### 使用细节
1. 接口不能被实例化
2. 所有方法都是public的（不写public也默认是public的），接口中的抽象方法可以不用abstract修饰
3. 一个普通类实现接口必须将接口中的所有方法都实现
4. 抽象类实现接口可以不实现接口的方法
5. 一个类同时可以实现多个接口（和继承extends不同）
6. 接口中的属性只能是final的，并且是public static final的，`int a;` = `public static final int a;`，必须初始化
7. 接口中属性访问的形式是`接口名.属性名`
8. 接口不能**继承**其他类，但能**继承多个**别的接口（多继承存在），接口不能**实现**别的接口。
9. 接口的修饰符只能是public和默认，和类的修饰符相同
10. 接口和父类中有重名属性可以用接口名制定接口中的属性，用super制定父类中的属性

### 接口VS继承类
- 解决问题不同
  - 继承解决代码复用性和可维护性
  - 接口实现设计，设计好各种规范，让其他类去实现
- 灵活程度不一样
  - 继承要满足is-a的关系
  - 接口满足like-a的关系
- 接口一定程度上实现代码解耦\[接口规范性+动态绑定\]

### 接口的多态
1. 多态参数：接口引用可以指向实现了接口的类的对象
2. 多态数组：接口数组中可以存放实现了该接口的不同的类
3. 接口中存在多态传递现象：接口继承了别的接口的话，被继承的接口的引用也可以指向实现了继承接口的类的实例。

## 内部类
一个类的内部又完整地嵌套了另一个类的结构，被嵌套的类被称为内部类，嵌套其他类的类被称为外部类，内部类最大的特点是可以直接访问私有属性，并体现类与类之间的嵌套关系

### 内部类的分类
- 定义在外部类局部位置上
  1. 局部内部类（有类名）：定义在局部位置（在方法中/代码块中），且有类名；可以访问所在外部类的所有成员；不能添加访问修饰符，相当于局部变量，可以用final修饰；作用域仅在定义它的方法或代码块中；局部内部类访问外部类成员可以直接访问；外部类只能在内部类的作用域内通过创建实例才能访问内部类的成员；外部其他类不能访问局部内部类（相当于局部变量）；外部类和局部内部类重名是遵循就近原则，想访问外部类成员可以用`外部类名.this.成员`去访问，外部类名.this本质是调用作用域所在方法/代码块的对象
  2. 匿名内部类（没有类名，重点）：本质是类、内部类、没有名字、同时也是一个对象；定义在局部位置（方法中/代码块中），没有类名；基本语法`new 类/接口(参数列表){类体};`；只使用一次且后面不再使用的情况使用匿名内部类减少类的数量，简化代码结构；`new 接口(){类体};`看似实例化了一个接口是错的，但实际上创建了一个匿名内部类（系统实际上分配了名字，形如外部类名$1，$后按顺序编号）来实现接口同时创建了一个实例并返回该实例的地址；`new 类(参数列表){类体};`看似像实例化了一个类，但其实是创建了一个继承了该类的匿名内部类（系统实际上分配了名字，形如外部类名$1，$后按顺序编号），并创建了该匿名内部类的一个实例并返回该实例的地址，参数列表会传递给构造器；可以直接访问外部类的所有成员；不能添加访问修饰符（相当于局部变量）；作用域仅在定义它的方法或代码块中；直接访问外部类成员；外部其他类不能访问匿名内部类；外部类和匿名内部类重名时遵守就近原则，访问外部类成员时用`外部类名.this.成员`去访问。应用：把匿名内部类作为实参传递
- 定义在外部类的成员位置上
  1. 成员内部类（没用static修饰）：定义在成员位置（像属性、方法一样的位置），且没有static修饰；可以直接访问外部类的所有成员；可以添加任意访问修饰符（相当于一个成员）；作用域和外部类其他成员一样，是整个类体；成员内部类可以直接访问外部类的成员；外部类通过创建对象访问成员内部类的成员（包括私有成员）；外部其他类可以通过外部类的实例来创建内部类的实例，`外部类类名.内部类类名 实例名 = 外部类实例.new 内部类类名()`，也可以在外部类中编写一个可以返回内部类的实例的方法；内部类和外部类成员重名时内部类访问遵循就近原则，想访问外部类成员使用`外部类名.this.成员`去访问。
  2. 静态内部类（使用static修饰）：定义在成员位置（像属性、方法一样的位置），且有static修饰；可以直接访问外部类所有静态成员，但不能直接访问非静态成员；可以添加任意访问修饰符（相当于一个成员）；作用域和外部类其他成员一样，是整个类体；静态内部类直接访问外部静态成员；外部类创建静态内部类实例再访问静态内部类成员；外部其他类可以通过外部类类名.内部类类名（符合访问权限）来创建静态内部类的实例，`外部类类名.内部类类名 实例名 = new 外部类类名.内部类类名()`，也可以在外部类中编写一个可以返回静态内部类的实例的（静态）方法；外部类和静态内部类成员重名的话，静态内部类访问时遵循就近原则，想访问外部类成员可以使用`外部类名.成员`去访问（因为静态内部类只能访问外部类的静态成员，所以this就没有意义了）。

## 枚举
用于对象固定（不需要修改）且有限的情况

枚举是一组常量的集合，是一种特殊的类，里面只包含一组有限的特定的对象。
### 自定义类实现枚举
1. 构造器私有化
2. 不要写set相关方法
3. 类内部创建一些实例，实例修饰为public final static，命名用大写字母加_，遵循常量命名规范
4. 枚举的对象根据需要可以有多个属性
### enum关键字实现枚举
1. 使用关键字enum替代class
2. 创建对象的语句替换成`对象名(构造器实参列表)`，多个对象用逗号间隔即可
3. enum实现枚举要将定义常量对象写在最前面

注意事项：
1. 使用enum关键字开发一个枚举类时，默认继承Enum类，而且这个枚举类是一个final类，不能被别的类继承
2. 简化后的写法必须知道使用的构造器
3. 使用无参构造器可以省略后面的小括号和实参列表
4. 多个枚举对象用逗号间隔，最后一个用分号结尾
5. 枚举对象必须方法枚举类的第一行
6. 枚举类的实例的name属性是实例名
7. 枚举类的实例的标号（ordinal）从0开始
8. `values()`方法返回该枚举类下所有的实例的名字
9. `valueOf(Class<T> enumType/*没有传入？？*/, String name)`方法将字符串转换为枚举类的实例，传入的name必须是已有的常量名，否则报异常
10. `compareTo(E o)`方法按照位置号比较两个枚举常量

> [!NOTE]
> `对象名(构造器实参列表)`是怎么调用Enum类的构造器'Enum(String name, int ordinal)'的？

使用细节：
1. 使用enum关键字后就不能继承其他类了，因为已经继承了Enum类，而Java中的类是单继承机制
2. 枚举类和普通类一样可以实现接口
## 注解
也被称为元数据（Metadata），用于修饰解释 包、类、方法、属性、构造器、局部变量等数据信息

和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息

在JavaSE中注解的使用目的比较简单，如标记过时的功能，忽略警告等，但在JavaEE中注解占据了更重要的角色，可以用来配置应用程序的任何切面、代替JavaEE旧版本中所遗留的繁冗代码和XML配置等

`@interface`，代表注解类，而不是接口
### JDK内置的基本注解类型
#### @Override
限定某个方法，是重写父类方法，只能用于方法，写了会校验该方法是否重写了父类方法，不是会报错，但不写这个注解不会有影响，源码中的`@Target(ElementType.METHOD)`表示只能修饰方法，`@Target`是修饰注解的注解，被称为元注解
#### @Deprecated
用于表示某个元素（类、方法等）已过时，表示不推荐使用，但还是可以使用的，可以用来做新旧版本的兼容和过渡，可以修饰方法、类、字段、包、参数等，源码中的`@Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE})`代表了可用范围
#### @SuppressWarnings
用于抑制编译器警告，`@SuppressWarnings({""})`可以来抑制警告信息，`{""}`中可以填写想要抑制的属性范围，输入的应该是String[]，作用范围和放置的位置相关，修饰谁就在谁的作用域里生效，可以修饰TYPE、FIELD、METHOD、PARAMETER、CONSTRUCTOR、LOCAL_VARIABLE上
### 元注解：对注解进行注解
