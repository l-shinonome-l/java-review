# Java概述
## Java的版本和组成
程序：**有序**指令的**集合**->解决问题。

Java 8、Java 11、Java 17、Java 21 LTS（Long-Term-Support）版本，需要重点学习feature。
> [!TIP]
> Java 17、Java 21本课程内没有，要再找资料学习。

Java技术体系平台：
- Java SE（Java Standard Edition）标准版
- Java EE（Java Enterprise Edition）企业版
- Java ME（Java Micro Edition）小型版（被Android替代了）

## Java的特点
Java的重要特点（不全，只有重点的）
1. 面向对象的（oop）。
2. 健壮的（rubust）。（强类型机制、异常处理、垃圾自动回收等保证健壮性）
3. 跨平台的。（.java文件编译为.class文件后，在不同平台的机器上运行不用再次编译，一次**编译**，Java虚拟机实现）
4. 半解释型半编译型[^1]（解释型：Javascript、PHP、Python，编译型：c/c++，编译后要解释器才能执行还是能直接被机器执行）
> [!NOTE]
> JVM中编译和解释并行存在，一开始是纯解释，但为了提高运行效率，加入JIT编译器（Just In Time Complier），将部分代码（以method为单位）编译为目标机器语言并保存提高效率。
[^1]:和课程内的不同，参考教科书和Javaguide进行了修正。

## Java开发工具
- editplus、notepad++
- Sublime Text
- **IDEA**
- eclipse
- **Visual Studio Code**

## jdk介绍
Java运行机制及运行过程：
.java文件编译为.class文件，.class在Java虚拟机（JVM）上运行，JVM通过屏蔽底层运行平台的差别，实现跨平台性。

JVM（Java Virtual Machine）：Java虚拟机，有指令集和不同的存储区域，负责执行指令，管理数据、内存、寄存器，不同系统平台要安装不同的JVM，在Java 9之前都在JRE里。
- JVM内存结构：
  - 栈：存放基本数据类型（局部变量）
  - 堆：存放对象
  - 方法区：常量池，类加载信息

JRE（Java Runtime Environment）：Java运行时环境，一般包括JVM和Java基础类库（Java Class Library），有JRE就可以运行.class文件，在JDK里。Java 9开始将jdk模块化，并提供jlink工具，来根据程序需要生成JRE，从Java 11开始不提供单独的JRE下载。

JDK（Java Development Kit）：Java开发工具包，它包含了 JRE和javac（编译.java为.class的编译器）、javadoc（文档注释工具）、JDB（Java Debugger，调试器）、jconsole（基于JMX（Java管理扩展，Java Management Extensions）的可视化监控⼯具）、javap（反编译工具）等工具。

Java 9前：JVM $`\in`$ JRE $`\in`$ JDK。

## 开发细节
1. .java文件由类组成。
2. 执行入口`main()`，固定写为`public static void main(String[] args){}`。
3. 严格区分大小写。
4. 语句以`;`结束。
5. 一个.java文件最多有一个public类，其他类不作限制，编译后每个类对应生成一个.class文件。
6. 如存在public类，.java文件必须要以这个public类的名字命名。
7. `main()`方法可以不在public类里，命令行运行指定类（.class文件）就可以访问非公共类里的main方法，IDE必须设定run Configurations的Main class。

## 转义字符
1. `\t`：制表位，实现对齐。
2. `\n`：换行。
3. `\\`：一个\\。
4. `\"`：一个\"。
5. `\'`：一个\'。
6. `\r`：一个回车，光标回到开头，不加`\n`则后面的字会覆盖前面的。

## 注释
注释：用于注解说明解释代码的文字，提高代码可读性。（快捷键：选中内容后ctrl+/，再按取消）
- 单行注释：`//注释内容`。
- 多行注释：`/*注视内容*/`。（无法嵌套）
- 文档注释：可被javadoc解析，写在类前，`@author`、`@version`等是javadoc标签，如下面代码块的.java文件可通过命令`javadoc -d output_path -author -version file_name`生成网页文件形式的说明文档。
```
/**
 * @author
 * @version
 */
```

## 代码规范
1. 类、方法的注释用javadoc的方法写。
2. 非javadoc的注释注重为什么这么写、如何修改、注意问题等。
3. 使用tab键缩紧，不要用多个空格。
4. 运算符和=左右加空格。
5. 源文件使用 utf-8 编码。
6. 行宽不要超过 80 个字符。
7. 次行风格、**行尾风格**（目前比较常见）：换行左大括号还是行尾左大括号。

# Java语法基础

## 变量
变量 = 类型 + 名称（地址） + 值

注意事项：
1. 先声明，后使用。
2. 同一作用域里不能重名。

### 基础变量类型
1 字节（byte） = 8 位（bit），1B = 8b。

- 数值型
  - 整数类型：1位符号位，其余数值位
    - byte：1 字节，- 2<sup>7</sup>~2<sup>7</sup> - 1，-128～127
    - short：2 字节，- 2<sup>15</sup>~2<sup>15</sup> - 1，-32768～32767
    - int：4 字节，- 2<sup>31</sup>~2<sup>31</sup> - 1，-2147483648～2147483647
    - long：8 字节，- 2<sup>63</sup>~2<sup>63</sup> - 1，具体值默认为int，要加`l`或`L`才能指定为long，如`1L`。
  - 浮点（小数）类型：符号位 + 指数位 + 尾数位（尾数部分可能丢失->精度损失，注意浮点数除法，小数相等判断时用差值绝对值在某个精度范围内）
    - float：4 字节，-3.403E38～3.403E38，具体值默认为double，要加`f`或`F`才能指定为float，如`1.1F`。
    - double：8 字节，-1.798E308～1.798E308
- 字符型
  - char：2 字节，也可以存放汉字，常量用单引号，本质是一个整数，代表unicode码对应字符，可运算，多个字符可以用String。
- 布尔型
  - boolean：1 字节，true/false，没有null。
### 类型转换
char->int->long->float->double

byte->short->int->long->float->double

**范围大的类型不能直接赋值给范围小的，范围小的类型赋值给范围大的或者和范围大的运算会自动转型**

#### 自动类型转换
注意事项：
- 多种类型混合计算会先转成最大的再计算。
- **具体数值**赋给byte、short和char时，虽然默认是int类型的，但会先判断范围，在范围内不会报错。
- byte和short有负数，char的范围是0～2<sup>16</sup>-1，（byte，short）和char之间没有包含关系，无法转换
- byte、short、char只要进行计算就会转换为int类型，不管是单类型运算还是混合运算。
- boolean不参与自动转换。
- 表达式的结果为操作数中最大的类型。

#### 强制类型转换
将容量大的数据类型转为容量小的数据类型，加上强制转换符`()`，只对最近的操作数有效。

不注意会导致127+1=-128这类bug，特别是底层隐形地使用了强制转换的时候（如++、+=）。

#### 基本数据类型和String类型转换
- 基本数据类型->String类型：最后加`+""`就行。
- String类型->基本数据类型：基本类型的包装类调用.parseXX方法，如`int a = Integer.parseInt("123")`。得到某一位字符用`.charAt()`。要确保能转为目标数据，不然会抛出异常。

### 引用数据类型
#### 类（class）
- String
  - 判断字符串相等用.equals()方法。
#### 接口（interface）
#### 数组（[]）
存放多个**同类**型数据的引用数据类型，下标从0开始，必须在\[0, .length - 1\]范围内使用，数组型数据是对象
- 长度：.length
-初始化
  - 动态初始化
    - 数据类型 `数组名[] = new 数据类型[大小];`/`数据类型[] 数组名 = new 数据类型[大小];`，
    - 数据类型 `数组名[];`/`数据类型[] 数组名;` `数组名 = new 数据类型[大小];`
    - 默认初始值：int 0, short 0, byte 0, long 0, float 0.0, double 0.0, char \u000, boolean false, String null（和""不同）
  - 静态初始化：`数据类型 数组名[] = {元素值, 元素值, ...};`
- 元素可以是基本类型，也可以是引用类型，但不能混用。
- 赋值机制
  - 基本数据类型赋值：赋值时赋值具体数值，是**值拷贝**，互不影响
  - 数组赋值：在默认情况下是**引用赋值**，赋的值是地址，不重新生成一个数组分配空间，把一个数组赋给另一个数组时，一个数组的变化会影响另一个（同一个地址有两个名字）
- 二维数组
  - 初始化：**动态**`数据类型[][] 数组名 = new 类型\[大小\]\[大小\]`/`数据类型[][] 数组名;` `数组名 = new 类型\[大小\]\[大小\]`，可以分配有几个一维数组（此时一维数组是null），再分别分配每一个一维数组；**静态**`类型 数组名[][] = {{值1, 值2...}, {值1, 值2...}};`
  - 内存：一维内存是连续的，但每个一维数组之间不一定连续，但存放每个一维数组地址的内存是连续的
  - 声明形式：`数据类型[][] 数组名`/`数据类型[] 数组名[]`/`数据类型 数组名[][]`

## 运算符
### 算数运算符
1. +：正号或加，左右两边是数值型，做加法；有一侧是字符串，做拼接。
2. -：负号或减
3. *：乘
4. /：除
5. %：取模，a % b = a - (int) (a / b) * b
6. ++/--：自增/减，`++i`，在前先运算再取值，`i++`，在后先取值再运算，有强制类型转换，所以byte、short、char也可以用。
```
//一个容易弄混的案例
int i = 1;
i = i++;  //1

int j = 1
j = ++j;  //2
```

### 赋值运算符
左边只能是变量，先执行右边，再赋值给左边

基本赋值运算符：=，赋值语句作为判断条件的话，根据被赋值的变量的值来判断true/false。

复合赋值运算符：+=、-=、*=、/=，会进行类型强制转换，等价于`a = (a的类型) a + _`所以byte、short、char也可以用。

### 关系运算符
结果是boolean
1. ==：等于
2. !=：不等于
3. <：小于
4. \>：大于
5. <=：小于等于
6. \>=：大于等于
7. instanceof：检查是否是累的对象 `"123" instanceof String  //true`

### 逻辑运算符
结果是boolean
1. &&：短路与，左侧为false则不会执行右边
2. ||：短路或，左侧为true则不会执行右边
3. !：取反
4. &：逻辑与，不短路，可用于位运算，按位与
5. |：逻辑或，不短路，可用于位运算，按位或
6. ^：异或，按位异或
### 三元运算符
`条件表达式 ? 表达式1 : 表达式2`

条件表达式为true则为表达式1，false则为表达式2。

表达式1和表达式2要为可以被变量接收的类型（或可以自动转换的类型）
### 优先顺序
运算顺序：除单目运算符和赋值运算符都是从左到右。
从上往下降低
- .  ()  {}  ;  ,
- ++  --  ~  !  (data type)
- \*  /  %
- \+  -
- \>>  <<  >>>  位移
- <  \>  <=  >=  instanceof
- ==  !=
- &
- ^
- |
- &&
- ||
- ?:
- =  *=  /=  %/  +=  -=  <<=  >>=  >>>=  &=  ^=  |=

## 标识符
可以自己取名的地方
### 规则
1. 由26个英文字母大小写，0-9，_或$组成
2. 数字不可以开头
3. 不能用关键字和保留字，但能包含
4. 严格区分大小写，无长度限制
5. 不能有空格
### 规范
1. 包名：多单词组成时所有字母小写
2. 类名、接口名：多单词组成时，所有单词首字母大写
3. 变量名、方法名：多单词组成时，第一个单词首字母小写，后面的首字母大写
4. 常量名：所有字母大写，多单词用下划线连接
### 关键字
都是小写
定义数据类型的

class、interfac、enum、byte、short、int、long、float、double、char、boolean、void

定义数据类型的值的

true、false、null

定义流程控制的

if、else、switch、case、default、while、do、for、break、continue、return
### 保留字
现版本没有使用，以后可能使用的

byValue、cast、future、generic、inner、operator、outer、rest、var、goto、const
## 键盘输入语句
扫描器Scanner类，所在包为java.util.*

步骤：
1. 导入包
2. 创建Scanner实例`Scanner scanner = new Scanner(System.in);`
3. 调用功能`String s = scanner.next()  // s为输入的下一行字符串`

## 四种进制
1. 二进制：0b或0B开头
2. 十进制：默认进制
3. 八进制：0开头
4. 十六进制：0x或0X开头，a-f不区分大小写

## 位运算
### 位运算符号
1. <<：算数左移，符号位不变，低位补0
2. \>>：算数右移，符号位不变，低位舍弃，用符号位补高位
3. \>>>：逻辑右移/无符号右移，低位舍弃，高位补0
4. ~：按位取反
5. &：按位与
6. |：按位或
7. ^：按位异或

### 原码、反码、补码
1. 二进制最高位是符号位，0是正数，1是负数
2. 正数的原码、反码、补码都一样
3. 负数的反码=原来的符号位+其他位取反
4. 负数的补码=负数的反码+1
5. 0的反码和补码都是0
6. java没有无符号数
7. 计算机用补码运算！！
8. 运算结果看原码！！

## 控制语句
### 顺序控制
从上往下执行
### 分支控制
具体数值不多且符合switch的6种类型就用switch，区间、true/false判断用if-else。
- if-else（嵌套最好不要超过3层）
  ```
  if (条件表达式) {
      代码块
  } else if (条件表达式) {
      代码块
  } else {
      代码块
  }
  ```
- switch
  ```
  switch (表达式){  //表达式应是后续常量的类型或者后续常量能转换成可以比较的类型，表达式只能是byte、short、int、char、enum、String
      case 常量1:
          代码块;
          break;  //没有break会穿透（不用判断case）执行后面的代码块，可用于处理多个case要执行统一操作
      case 常量2:
          代码块;
          break;
      ...
      default:
          代码块;
  }
  ```
### 循环控制
嵌套不要超过3层最好，最多不要超过4层
- for
  ```
  for (循环变量初始化;循环条件;循环变量迭代) { // 循环变量初始化和循环变量迭代可以省略，但分号要有，可以初始化多个变量，但类型要一样，变量迭代也可以有多个
      代码块
  }
  ```
- while
  ```
  循环变量初始化
  while (循环条件) {
      代码块
      循环变量迭代
  }
  ```
- do-while（一定会执行一次）
  ```
  循环变量初始化
  do {
      代码块
      循环变量迭代
  } while (循环条件);
  ```
### break
跳出当前循环/switch分离case，（尽量不要用）配合标签在多重循环中退出哪一层，标签放在循环语句前`标签:`，`break 标签;`
### continue
跳过之后的循环体，进入下一次循环，（尽量不要用）配合标签在多重循环中跳过哪一层，标签放在循环语句前`标签:`，`continue 标签;`
### return
在方法中使用，跳出所在方法
# 面向对象编程
## 类与对象
类：引用数据类型，有属性和行为

对象：对象（实例）之于类 = 变量之于基础数据类型，可以先声明再创建`类名 对象名;` `对象名 = new 类名();`，也可以直接创建`类名 对象名 = new 类名();`

### 对象在内存中的存在形式
执行`new 类名()`时，会在方法区加载类信息，包括属性信息和方法信息，

执行`类名 对象名 =`时，对象名在栈里存的是地址，对象在堆里开辟对应的空间里，堆中引用数据类型存的是地址，基础数据类型存数据，引用数据类型的常量存在方法区中

### 类与对象的内存分配机制
`类名 对象名 = new 类名()`的流程：
1. 执行`new 类名()`，先在方法区加载类信息（一个类只加载一次），然后在堆里开辟空间创建对象，所有属性都是默认值
2. 执行`类名 对象名 =`，在栈里创建对象名，赋值为创建的对象的地址
### 属性/成员变量
成员变量 = 属性 = field

属性是类的组成部分，可以说基础数据类型，也可以是引用类型。

定义语法：`访问修饰符 属性类型 属性名;`，不赋值由默认值，规则和数组一样

访问属性：`对象名.属性名`

### 成员方法
定义：`访问修饰符 返回数据类型 方法名(形参类型 形参1, ... 形参类型 形参n){方法体}`，返回类型和return的值一致或兼容，方法不能嵌套定义。

使用：`对象名.方法名(实参1,...)`，方法调用传入的参数为实参，实参和形参的类型要兼容或一致，个数、顺序也要一致。一个方法调用同一个类的方法可以直接调用，要调用别的类的方法要创建该类的对象来调用

传参机制：基本数据类型进行值拷贝，形参的任何变化不影响实参，引用数据类型传的是地址，对内容进行改动会改变地址指向空间里的内容，所以实参地址指向的内容也会随之改变。

### 方法重载（Overload）
允许多个同名方法存在，但同名方法的形参方法一定要不同，多个形参列表都兼容的时候配最近的，返回类型不构成方法重载的条件，只有返回类型不同会造成方法重复，报错。

### 可变参数
将多个同名同功能但参数个数不同的方法封装成一个方法。

可变参数的实参可以有0个或多个，实参可以是数组，本质就是数组，可变参数必须在最后，一个形参列表只能有一个可变参数

`访问修饰符 返回类型 方法名(数据类型... 形参名){}`

### 作用域
全局变量：属性，作用域为整个类体，定义时可以直接赋值，不赋值也有默认值可以使用，可以被本类和其他类（对象调用，创建或直接传入对象地址皆可）使用，可以加修饰符。

局部变量：除属性之外的其他变量，在成员方法中定义的变量+代码块中的变量，作用域为定义它的代码块，必须要先赋值才能使用，只能在本类中对应的方法中使用，不可以加修饰符。

属性和局部变量可以重名，访问时根据就近原则，同一作用域中，两个局部变量不能重名

### 构造器
类的一种特殊方法，完成对新对象的初始化（对象的空间已创建了，构造器没有创建对象，new创建空间）

定义：`[修饰符] 方法名(形参列表){方法体;}`[]代表可以用默认修饰符

**没有返回值**，方法名和类名相同，参数列表和成员方法一样的规则，创建对象时（new），系统自动调用该类的构造器完成对对象的初始化，可以有多个不同构造器（构造器重载），没有定义构造器的话，系统会自动生成一个默认的无参构造器，但一旦自己定义了构造器就没有默认的无参构造器了，要用需要自己定义。

### this关键字
属性和局部变量重名会无法区分局部变量和属性，所以用`this`来区分局部变量和属性。

this代表当前对象，`this.属性名`代表属性，每个对象的空间里都保存了一个自己所在空间的地址，这个地址就是this

this可以访问本类的属性、方法、构造器，访问方法`this.方法名(参数列表);`，访问构造器`this(参数列表);`（只能在构造器内使用）且必须在第一行，this不能在类定义的外部使用，只能在类定义的方法中使用。

## 包
### 包的基础概念
- 作用：
  - 区分相同名字的类
  - 管理类
  - 控制访问范围
- 基本语法：
  - 定义包：`package com.hspedu;`，要是文件的第一句非注释语句，一个.java文件中最多只有一句package，同一个.java文件里的类必须在同一个包里
    - `package`=关键字，表示打包
    - 包名为`com.hspedu`
  - 引入包：`import 包;`，`.类`是引入类，`.*`是引入包内所有类，最好使用哪些类就导入哪些类，在package下面，类前面，同一个包内的类（因为private不能修饰）不用引用
- 本质：创建不同文件夹来保存类文件
### 包的命名
- 命名规则：
  - 只能包含数字、字母、下划线、点，
  - 不能数字开头
  - 不能是关键字或保留字
- 命名规范：
  - 小写字母+.
  - com.公司名.项目名.业务模块名
### 常用的包
- java.lang.*：默认引用
- java.util.*：系统提供的工具包，工具类，Scanner
- java.net.*：网络包
- java.awt.*：界面开发，GUI

### 访问修饰符
四种：public、protected、默认、private，控制方法和属性的访问范围，可以修饰类中的属性、成员方法，只有默认和public可以修饰类
- public：对外公开，不同包也可以访问
- protected：对子类和同一个包中的类公开
- 默认：向同一个包的类公开
- private：只有类本身可以访问

## 三大特征
### 封装
把抽象出的属性和方法封装在一起，属性被保护在内部，只能通过被授权的方法才能对属性进行操作。

好处：
- 隐藏实现细节
- 可以对数据进行验证，保证安全合理

步骤：
1. 将属性私有化（设为private）
2. 提供一个公共（public）的set方法
3. 提供一个公共（public）的get方法

要注意构造器的不恰当使用可能破坏封装。
### 继承
解决相似类的代码冗余，增加代码复用性，扩展性和维护性也提高了。可以抽象出父类（超类、基类），所有的子类（派生类）都不用再定义这些方法和属性，自动拥有父类定义的属性和方法，只写自己特有的方法就行。

基本语法：`class 子类 extends 父类{}`

注意事项：
- 子类继承所有属性和方法，不是private的属性和方法子类都能直接访问，但private属性和方法要通过**父类的公共方法**才能访问
- 子类必须调用父类的构造器，完成父类的初始化
- 创建子类对象时，不管子类使用哪个构造器，默认都使用父类的无参构造器，没有无参构造器则要在子类构造器中用super去指定使用哪个父类构造器
- 如果希望指定调用父类的构造器可以显示调用`super(参数列表);`
- 用super时必须在构造器的第一行
- super和this在同一个构造器里不能共存
- 所有类都是Object类的子类
- 父类构造器的调用不限于直接父类，会一直追溯到Object类
- 最多只能继承一个直接父类，是单继承机制
- 子类和父类之间要满足is-a关系，不能滥用

继承的本质：创建子类对象后，建立子类和父类之间的查找关系，使用时，子类有属性且可以访问则返回信息，不能访问会报错返回，没有就向上找，直到Object
### 多态
# 数据结构与算法
## 数据结构
## 算法
### 查找算法
- 顺序查找：
- 二分查找：只能查找有序数组
### 排序算法
- 内部排序：将所有数据都加载到内部存储器进行排序
  - 交换式排序
    - 冒泡排序：n个数，执行n - 1趟，第i趟比较n - i次，从0开始，比较j和j + 1，j大则交换（升序）
      ```
      public static int[] bubbleSort (int[] arr) {
          for (int i = 1; i < arr.length; i++) {
              for (int j = 0; j < arr.length - i; j++) {
                  if (arr[j] > arr[j + 1]) {
                      int temp = arr[j];
                      arr[j] = arr[j + 1];
                      arr[j + 1] = temp;
                  }
              }
          }
          return arr;
      }
      ```
  - 选择式排序
  - 插入式排序
- 外部排序：数据量过大无法全部加载到内存中，需要借助外部存储进行排序
  - 合并排序法
  - 直接合并排序法
### 递归
- 汉诺塔
  ```
  public void HanoiTower(int num, char a, char b, char c) {
      if (num == 1) {
          System.out.println(a + "->" + c);
          return;
      }
      HanoiTower(n - 1, a, c, b);
      System.out.println(a + "->" + c);
      HanoiTower(n - 1, b, c, a);
  }
  ```
